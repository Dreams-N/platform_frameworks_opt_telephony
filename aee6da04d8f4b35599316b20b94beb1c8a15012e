Revision: aee6da04d8f4b35599316b20b94beb1c8a15012e
Patch-set: 12
File: /COMMIT_MSG

17
Thu Sep 06 09:57:51 2012 +0000
Author: Wink Saville <1001401@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAI6n//6xw=
Bytes: 1513
Minor grammatical changes:

The primary advantage of UiccController is that we can work with multiple uicc applications
at the same time. And that is a requirement for modes like Cdma/Lte. The existing code supports
Cdma/Lte only partially and with guessing on modem side. However, some things modem can
guess, while others - it can't.

For instance, when a user tries to edit the fdn list the current code will pass ef_id for fdn (0x6F3B).
But the modem will have no clue which fdn list the user wants to edit (csim or usim, both have path 7FFF),
and it's impossible for modem to guess correctly all the time. All the modem can do is try to
be consistent and hope another device is doing same things. Imagine you bring your card from
another Cdma/Lte device to your new Cdma/Lte device: if this modem uses different fdn file, it
won't work as all existing entries won't be there.

Another example is when the modem's guess is wrong for files like csim/ef_li (7FFF 6F3A)
versus usim/ef_adn (7FFF 6F3A). They have same ef_ids so Android really should pass aid
of the app it wants to access. Without aids there is no way modem can know for sure which
file Android wants to read! However, in the current code even Android doesn't know which
aid it wants to read file from since CdmaLteRecords has only 1 aid.

All of these problems cause more and more hacks, both in the modem and in Android side.
UiccController cleans up current code and provides framework to work with multiple Uicc
applications at the same time.

File: src/java/com/android/internal/telephony/UiccCardApplication.java

236
Thu Sep 06 09:57:51 2012 +0000
Author: Wink Saville <1001401@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAI6n//6xk=
Bytes: 92
/* REMOVE this method once mIccLockEnabled is not needed */
 private void queryPin1State() {

246
Thu Sep 06 09:57:51 2012 +0000
Author: Wink Saville <1001401@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAI6n//6xg=
Bytes: 94
Delete:
  * Interoperate ...

 Add:
  * REMOVE this method once mIccLockEnabled is not needed.

265
Thu Sep 06 09:57:51 2012 +0000
Author: Wink Saville <1001401@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAI6n//6xc=
Bytes: 342
Reword:
  // Sanity check: we expect mPin1State to match mIccLockEnabled.
  // When mPin1State is DISABLED mIccLockEanbled should be false.
  // When mPin1State is ENABLED mIccLockEnabled should be true.
  //
  // Here we validate these assumptions to assist in identifying which ril/radio's
  // have not correctly implemented GET_SIM_STATUS

269
Thu Sep 06 09:57:51 2012 +0000
Author: Wink Saville <1001401@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAI6n//6xY=
Bytes: 19
Remove this comment

280
Thu Sep 06 09:57:51 2012 +0000
Author: Wink Saville <1001401@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAI6n//6xU=
Bytes: 20
Remove this comment.

551
Thu Sep 06 09:57:51 2012 +0000
Author: Wink Saville <1001401@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAI6n//6xo=
Bytes: 130
/* STOPSHIP: Remove line above and all code associated with setting
  mIccLockEanbled once all RIL correctly sends the pin1 state.

